dailyres=autoCompoundModel(DataFrame = Calls,TimeColumnName ='Time' ,
FeatureName = 'Calls',SplitDataAt = 1600,Frequency = 'day',
ForecastPeriods = 226,PlotIt = T,
Holidays = Holidays)
dailyres$Accuracy
1-abs(mean(dailyres$TestData$y) - dailyres$Accuracy[2,3])/dailyres$Accuracy[2,3]
abs(mean(dailyres$TestData$y) - dailyres$Accuracy[2,3])
dailyres$Accuracy[2,3]
mean(abs(dailyres$TestData$y) - dailyres$Accuracy[2,3])
dailyres$TestData$y
dailyres$Accuracy[2,3]
mean(dailyres$TestData$y)
library(TimeSeries)
?TimeSeries::autoCompoundModel
AutoCorr(Calls$Calls,nLags = 40,PlotIt = T)
AutoCorr(Calls$Calls,nLags = 400,PlotIt = T)
source('D:/Subversion/PUB/dbt/TimeSeries/R/AutoCorr.R')
AutoCorr(Calls$Calls,nLags = 400,PlotIt = T)
source('D:/Subversion/PUB/dbt/TimeSeries/R/CrossCorr.R')
source('D:/Subversion/PUB/dbt/TimeSeries/R/PartialAutoCorr.R')
PartialAutoCorr(Calls$Calls,nLags = 400,PlotIt = T)
CrossCorr(Calls$Calls,df$number_of_answered_calls,nLags = 400,PlotIt = T)
AutoCorr(Calls$Calls,nLags = 400,PlotIt = T)
PartialAutoCorr(Calls$Calls,nLags = 400,PlotIt = T)
PartialAutoCorr(Calls$Calls,nLags = 100,PlotIt = T)
PartialAutoCorr(Calls$Calls,nLags = 60,PlotIt = T)
?arma
?ARMA
ARMAacf()
?ARMAacf()
res=arima(Calls$Calls,order=c(50,0,0))
requireRpackage('FitAR')
?FitAR
res=FitAR::FitAR(Calls$Calls,50)
View(res)
plot(res$fits)
plot(res$fits,type='l')
points(Calls$Calls,type='l','red')
points(Calls$Calls,type='l',cols='red')
plot(res$fits,type='l')
points(Calls$Calls,type='l',cols='red')
plot(res$fits,type='l')
points(Calls$Calls,type='l',col='red')
InspectVariable(Calls$Calls-res$fits)
res=FitAR::FitAR(Calls$Calls[1:1600],50)
plot(res$fits,type='l')
points(Calls$Calls[1:1600],type='l',col='red')
InspectVariable(Calls$Calls-res$fits)
test=predict(res,n.ahead = 286)
nrow(Calls$Call)
nrow(Calls)
test=predict(res,n.ahead = 226)
View(test)
plot(Calls$Calls[1601:1826],type='l')
points(test$Forecasts,type='l',cols='red')
plot(Calls$Calls[1601:1826],type='l')
points(test$Forecasts,type='l',col='red')
plot(Calls$Calls[1601:1826],type='l')
points(test$Forecasts,type='l',col='red')
test$Forecasts
test$Forecasts[1]
points(as.vector(test$Forecasts),type='l',col='red')
points(as.vector(test$SDForecasts),type='l',col='blue')
mean(abs(Calls$Calls[1601:1826]-as.vector(test$Forecasts)))
mean(abs(Calls$Calls[1601:1826]-as.vector(test$Forecasts)))/mean(Calls$Calls[1601:1826])
res=FitAR::FitAR(Calls$Calls[1:1600],51)
plot(res$fits,type='l')
points(Calls$Calls[1:1600],type='l',col='red')
InspectVariable(Calls$Calls-res$fits)
test=predict(res,n.ahead = 226)
plot(Calls$Calls[1601:1826],type='l')
points(as.vector(test$Forecasts),type='l',col='red')
mean(abs(Calls$Calls[1601:1826]-as.vector(test$Forecasts)))/mean(Calls$Calls[1601:1826])
View(holidays2)
path='D:/Viessmann2018Q2/99RawData/Anrufvolumen'
setwd(path)
#
# library(readxl)
# df=readxl::read_xlsx('Anzahl_Anrufe_je_Tag.xlsx')
df=read.csv('total_calls_and_answered_calls_per_day.csv',stringsAsFactors = FALSE)
plot(Time,df$number_of_calls,type='l')
points(Time,df$number_of_answered_calls,type='l',col='red')
Time=strptime(df$date,'%Y-%m-%d')
plot(Time,df$number_of_lost_calls,type='l')
plot(Time,df$number_of_calls,type='l')
plot(Time[1:30],df$number_of_calls[1:30],type='l')
plot(Time[1:10],df$number_of_calls[1:10],type='l')
Time[1:10]
plot(Time[1:15],df$number_of_calls[1:15],type='l')
res=FitAR::FitAR(Calls$Calls[1:1600],51)
plot(res$fits,type='l')
points(Calls$Calls[1:1600],type='l',col='red')
Time=strptime(df$date,'%Y-%m-%d')
Calls=data.frame(Time=as.Date(Time),Calls=df$number_of_calls)
res=FitAR::FitAR(Calls$Calls[1:1600],51)
plot(res$fits,type='l')
points(Calls$Calls[1:1600],type='l',col='red')
plot(Calls$Calls[1601:1826],type='l')
points(as.vector(test$Forecasts),type='l',col='red')
test=predict(res,n.ahead = 226)
points(as.vector(test$Forecasts),type='l',col='red')
InspectVariable(Calls$Calls-res$fits)
df$weekday[1:14]
ind=which(df$weekday<5)
plot(Time[ind],df$number_of_calls[ind],type='l')
points(Time[ind],df$number_of_answered_calls[ind],type='l',col='red')
plot(Time[ind],df$number_of_calls[ind]-df$number_of_answered_calls[ind])
plot(Time[ind],df$number_of_calls[ind]-df$number_of_answered_calls[ind],type='l')
CallsDiff=data.frame(Time=as.Date(Time[ind]),Calls=df$number_of_calls[ind]-df$number_of_answered_calls[ind])
dailyres=autoCompoundModel(DataFrame = Calls,TimeColumnName ='Time' ,
FeatureName = 'Calls',SplitDataAt = 1600,Frequency = 'day',
ForecastPeriods = 226,PlotIt = T,
Holidays = Holidays)
Holidays=data.frame(ds=as.Date(dates),holiday=names
)
dates=df$date[df$holiday==1]
names=df$Feiertag[df$holiday==1]
Holidays=data.frame(ds=as.Date(dates),holiday=names
)
dailyres=autoCompoundModel(DataFrame = Calls,TimeColumnName ='Time' ,
FeatureName = 'Calls',SplitDataAt = 1600,Frequency = 'day',
ForecastPeriods = 226,PlotIt = T,
Holidays = Holidays)
dailyres=autoCompoundModel(DataFrame = CallsDiff,TimeColumnName ='Time' ,
FeatureName = 'Calls',SplitDataAt = 1600,Frequency = 'day',
ForecastPeriods = 226,PlotIt = T,
Holidays = Holidays)
dailyres=autoCompoundModel(DataFrame = CallsDiff,TimeColumnName ='Time' ,
FeatureName = 'Calls',SplitDataAt = 1000,Frequency = 'day',
ForecastPeriods = 305,PlotIt = T,
Holidays = Holidays)
dailyres=autoCompoundModel(DataFrame = CallsDiff,TimeColumnName ='Time' ,
FeatureName = 'Calls',SplitDataAt = 1000,Frequency = 'day',
ForecastPeriods = 305,PlotIt = T,
Holidays = Holidays)
dailyres=autoCompoundModel(DataFrame = CallsDiff,TimeColumnName ='Time' ,
FeatureName = 'Calls',SplitDataAt = 1000,Frequency = 'day',
ForecastPeriods = 305,PlotIt = T)
dailyres=autoCompoundModel(DataFrame = CallsDiff,TimeColumnName ='Time' ,
FeatureName = 'Calls',SplitDataAt = 1000,Frequency = 'day',
ForecastPeriods = 304,PlotIt = T,Holidays
Holidays = )
dailyres=autoCompoundModel(DataFrame = CallsDiff,TimeColumnName ='Time' ,
FeatureName = 'Calls',SplitDataAt = 1000,Frequency = 'day',
ForecastPeriods = 304,PlotIt = T,
Holidays = Holidays)
dailyres=autoCompoundModel(DataFrame = CallsDiff,TimeColumnName ='Time' ,
FeatureName = 'Calls',SplitDataAt = 1000,Frequency = 'week',
ForecastPeriods = 304,PlotIt = T,
Holidays = Holidays)
dailyres=autoCompoundModel(DataFrame = CallsDiff,TimeColumnName ='Time' ,EquiDist = F
FeatureName = 'Calls',SplitDataAt = 1000,Frequency = 'day',
ForecastPeriods = 304,PlotIt = T,
Holidays = Holidays)
dailyres=autoCompoundModel(DataFrame = CallsDiff,TimeColumnName ='Time' ,EquiDist = F,
FeatureName = 'Calls',SplitDataAt = 1000,Frequency = 'day',
ForecastPeriods = 304,PlotIt = T,
Holidays = Holidays)
dailyres=autoCompoundModel(DataFrame = CallsDiff,TimeColumnName ='Time' ,EquiDist = F,
FeatureName = 'Calls',SplitDataAt = 1000,Frequency = 'day',
ForecastPeriods = 600,PlotIt = T,
Holidays = Holidays)
dailyres=autoCompoundModel(DataFrame = Calls,TimeColumnName ='Time' ,EquiDist = F,
FeatureName = 'Calls',SplitDataAt = 1000,Frequency = 'day',
ForecastPeriods = 600,PlotIt = T,
Holidays = Holidays)
ind=which(df$weekday>4)
plot(Time[ind],df$number_of_calls[ind],type='l')
points(Time[ind],df$number_of_answered_calls[ind],type='l',col='red')
ind=which(df$weekday>4)
plot(Time[ind],df$number_of_calls[ind],type='l')
ind=which(df$weekday>5)
plot(Time[ind],df$number_of_calls[ind],type='l')
points(Time[ind],df$number_of_answered_calls[ind],type='l',col='red')
range(df$weekday)
ind=which(df$weekday==6)
plot(Time[ind],df$number_of_calls[ind],type='l')
points(Time[ind],df$number_of_answered_calls[ind],type='l',col='red')
weeks = seq(
from=as.Date(min(Calls$Time)), to=as.Date(Calls$Time), by ='week'
)
weeks = seq(
from=as.Date(min(Calls$Time)), to=as.Date(max(Calls$Time)), by ='week'
)
test=aggregate(Calls$Calls, weeks sum)
test=aggregate(Calls$Calls, weeks, sum)
test=aggregate(Calls$Calls, list(weeks), sum)
test=aggregate(Calls, list(weeks), sum)
Calls$Time[1]
sprintf("%s%05d", format(x, "%Y-%m-Week"), weeks(x) - weeks(x[1]) + 1)
fmt <- function(x) {
weeks <- function(x) as.numeric(x + 3) %/% 7 + 1
sprintf("%s%05d", format(x, "%Y-%m-Week"), weeks(x) - weeks(x[1]) + 1)
}
aggregate(Calls$Calls, list(Date = fmt(Calls$Time)), sum)
test=aggregate(Calls$Calls, list(Date = fmt(Calls$Time)), sum)
test[1]
test$x[1]
Calls$Calls[1:7]
sum(Calls$Calls[1:7])
df$weekday[1:7]
weeklyres=autoCompoundModel(DataFrame = test,TimeColumnName ='Date' ,
FeatureName = 'x',SplitDataAt = 280,Frequency = 'week',
ForecastPeriods = 32,PlotIt = T,
Holidays = Holidays)
Weekly=data.frame(
weeks = seq(
from=as.Date(min(Calls$Time)), to=as.Date(max(Calls$Time)), by ='week'
),
Calls=test$x
)
weeks = seq(
from=as.Date(min(Calls$Time)), to=as.Date(max(Calls$Time)), by ='week'
)
weeks[1]
weeks[261]
test$Date[1]
test$Date[312]
test$Date
test[5:6,]
test[6:7,]
library(lubridate)
?tapply
?week
?year
source('D:/Subversion/PUB/dbt/TimeSeries/R/AggegateDaysToWeeks.R')
lubridate::years(Calls$Time)
lubridate::years(as.Date(Calls$Time))
as.Date(Calls$Time)
lubridate::year(as.Date(Calls$Time))
Years=unique(lubridate::year(as.Date(Calls$Time)))
source('D:/Subversion/PUB/dbt/TimeSeries/R/AggegateDaysToWeeks.R')
test=AggegateDaysToWeeks(Calls$Calls,Calls$Time)
test$Weeks[1:3]
test$WeeklyTime[1:3]
Calls[1:3,]
Calls[1:15,]
test$Weeks[1:3]
test$WeeklyTime[1:3]
6149+5088+5022+5091+1319+352
6149+5088+5022+5091+1319+352+5533
source('D:/Subversion/PUB/dbt/TimeSeries/R/AggegateDaysToWeeks.R')
test=AggegateDaysToWeeks(Calls$Calls,Calls$Time)
test$Weeks[1:3]
test$Weeks[1:3]
source('D:/Subversion/PUB/dbt/TimeSeries/R/AggegateDaysToWeeks.R')
test$Weeks[1:3]
test=AggegateDaysToWeeks(Calls$Calls,Calls$Time)
test$Weeks[1:3]
Data=Calls$Call
Time=Calls$Time
Time=as.Date(Time)
requireNamespace('lubridate')
Years=unique(lubridate::year(as.Date(Time)))
AllWeeks=c()
Years[i]
i=1
Years[i]
ind=which(lubridate::year(Time)==Years[i])
a=Data[ind]
a
b=lubridate::week(Time)[ind]
b
?lubridate::wee
?lubridate::week
Time[1:8]
df$weekday[1:8]
lubridate::week(Time)[1:8]
lubridate::isoweek(Time)[1:8]
source('D:/Subversion/PUB/dbt/TimeSeries/R/AggegateDaysToWeeks.R')
test=AggegateDaysToWeeks(Calls$Calls,Calls$Time)
test$Weeks[1:3]
test$WeeklyTime[1:3]
df$number_of_calls[1:15]
df$number_of_calls[1:15,]
df[1:15,]
df[1:15,1:2]
test$Weeks[1:3]
ind=which(lubridate::year(Time)==Years[i])
a=Data[ind]
a[1:10]
b=lubridate::isoweek(Time)[ind]
b[1:10]
tapply(a, b, sum)
tapply(a[1:10], b[1:10], sum)
source('D:/Subversion/PUB/dbt/TimeSeries/R/AggegateDaysToWeeks.R')
x=tapply(a, b, sum)
names(x)=unique(b)
x=head(x,n = length(x)-1)
x[1:3]
plot(Time,df$number_of_calls,type='l')
points(Time,df$number_of_answered_calls,type='l',col='red')
df=read.csv('total_calls_and_answered_calls_per_day.csv',stringsAsFactors = FALSE)
plot(Time,df$number_of_calls,type='l')
points(Time,df$number_of_answered_calls,type='l',col='red')
Time=strptime(df$date,'%Y-%m-%d')
plot(Time,df$number_of_lost_calls,type='l')
path='D:/Viessmann2018Q2/99RawData/Anrufvolumen'
setwd(path)
#
# library(readxl)
# df=readxl::read_xlsx('Anzahl_Anrufe_je_Tag.xlsx')
df=read.csv('total_calls_and_answered_calls_per_day.csv',stringsAsFactors = FALSE)
plot(Time,df$number_of_calls,type='l')
points(Time,df$number_of_answered_calls,type='l',col='red')
Time=strptime(df$date,'%Y-%m-%d')
plot(Time,df$number_of_lost_calls,type='l')
plot(Time,RelDiffWithYesterday(df$number_of_calls),type='l')
InspectVariable(RelDiffWithYesterday(df$number_of_calls))
delta=RelDiffWithYesterday(df$number_of_calls)
res=AdaptGauss(delta)
Cls=BayesClassification(delta,res$Means,res$SDs,res$Weights)
plot(delta,col=Cls$Cls,type='l')
plot(delta,col=Cls$Cls)
fanPlot(df$weekday[Cls==1])
fanPlot(df$weekday[Cls$Cls==1])
fanPlot(df$weekday[Cls$Cls==2])
fanPlot(df$weekday[Cls$Cls==3])
fanPlot(df$weekday[Cls$Cls==2])
fanPlot(df$weekday[Cls$Cls==1])
fanPlot(df$weekday[Cls$Cls==3])
res=TimeSeries::MovingAverage(df$number_of_calls,7,PlotIt = T)
TimeSeries::MovingAverage
source('D:/Subversion/PUB/dbt/TimeSeries/R/MovingAverage.R')
res=TimeSeries::MovingAverage(df$number_of_calls,7,PlotIt = T)
res[1:3]
df$number_of_calls[1]
df$number_of_calls[2]
res=TimeSeries::MovingAverage(c(0,df$number_of_calls),7,PlotIt = T)
res[1:3]
res=TimeSeries::MovingAverage(c(NaN,df$number_of_calls),7,PlotIt = T)
res[1:3]
df$number_of_calls[1:7]
mean(df$number_of_calls[1:7])
median(df$number_of_calls[1:7])
?signal::filter
source('D:/Subversion/PUB/dbt/TimeSeries/R/MovingAverage.R')
res=TimeSeries::MovingAverage(df$number_of_calls,7,PlotIt = T)
res[1:3]
source('D:/Subversion/PUB/dbt/TimeSeries/R/MovingAverage.R')
res[1:3]
res=TimeSeries::MovingAverage(df$number_of_calls,7,PlotIt = T)
res[1:3]
res=TimeSeries::MovingAverage(df$number_of_calls,7,PlotIt = T)
res[1:3]
source('D:/Subversion/PUB/dbt/TimeSeries/R/MovingAverage.R')
res=TimeSeries::MovingAverage(df$number_of_calls,7,PlotIt = T)
res=MovingAverage(df$number_of_calls,7,PlotIt = T)
source('D:/Subversion/PUB/dbt/TimeSeries/R/MovingAverage.R')
res=MovingAverage(df$number_of_calls,7,PlotIt = T)
source('D:/Subversion/PUB/dbt/TimeSeries/R/MovingAverage.R')
res=MovingAverage(df$number_of_calls,7,PlotIt = T)
source('D:/Subversion/PUB/dbt/TimeSeries/R/MovingAverage.R')
res=MovingAverage(df$number_of_calls,7,PlotIt = T)
source('D:/Subversion/PUB/dbt/TimeSeries/R/MovingAverage.R')
res=MovingAverage(df$number_of_calls,7,PlotIt = T)
res[1:3]
Calls=data.frame(Time=as.Date(Time),Calls=res)
nrow(Calls)
dates=df$date[df$holiday==1]
names=df$Feiertag[df$holiday==1]
Holidays=data.frame(ds=as.Date(dates),holiday=names
)
dailyres=autoCompoundModel(DataFrame = Calls,TimeColumnName ='Time' ,
FeatureName = 'Calls',SplitDataAt = 1600,Frequency = 'day',
ForecastPeriods = 226,PlotIt = T,
Holidays = Holidays)
dailyres$Accuracy
dailyres=autoCompoundModel(DataFrame = Calls,TimeColumnName ='Time' ,
FeatureName = 'Calls',SplitDataAt = 1800,Frequency = 'day',
ForecastPeriods = 26,PlotIt = T,
Holidays = Holidays)
dailyres$Accuracy
dailyres=autoCompoundModel(DataFrame = Calls,TimeColumnName ='Time' ,
FeatureName = 'Calls',SplitDataAt = 1820,Frequency = 'day',
ForecastPeriods = 4,PlotIt = T,
Holidays = Holidays)
dailyres$Accuracy
dailyres=autoCompoundModel(DataFrame = Calls,TimeColumnName ='Time' ,
FeatureName = 'Calls',SplitDataAt = 1820,Frequency = 'day',
ForecastPeriods = 1,PlotIt = T,
Holidays = Holidays)
dailyres=autoCompoundModel(DataFrame = Calls,TimeColumnName ='Time' ,
FeatureName = 'Calls',SplitDataAt = 1820,Frequency = 'day',
ForecastPeriods = 2,PlotIt = T,
Holidays = Holidays)
dailyres=autoCompoundModel(DataFrame = Calls,TimeColumnName ='Time' ,
FeatureName = 'Calls',SplitDataAt = 1820,Frequency = 'day',
ForecastPeriods = 3,PlotIt = T,
Holidays = Holidays)
dailyres=autoCompoundModel(DataFrame = Calls,TimeColumnName ='Time' ,
FeatureName = 'Calls',SplitDataAt = 1820,Frequency = 'day',
ForecastPeriods = 4,PlotIt = T,
Holidays = Holidays)
dailyres=autoCompoundModel(DataFrame = Calls,TimeColumnName ='Time' ,
FeatureName = 'Calls',SplitDataAt = 1800,Frequency = 'day',
ForecastPeriods = 4,PlotIt = T,
Holidays = Holidays)
dailyres=autoCompoundModel(DataFrame = Calls,TimeColumnName ='Time' ,
FeatureName = 'Calls',SplitDataAt = 1822,Frequency = 'day',
ForecastPeriods = 4,PlotIt = T,
Holidays = Holidays)
dailyres$Accuracy
source('D:/Subversion/PUB/dbt/TimeSeries/R/WaveletFilter.R')
res=WaveletFilter(Calls$Calls,percent = '12.5')
library(waveslim)
res=WaveletFilter(Calls$Calls,percent = '12.5')
res=WaveletFilter(Calls$Calls,percent = '50')
source('D:/Subversion/PUB/dbt/TimeSeries/R/WaveletFilter.R')
res=WaveletFilter(Calls$Calls,percent = '50')
plot(res)
plot(res)
plot(res[[1]])
res=WaveletFilter(Calls$Calls,percent = '25')
res=WaveletFilter(Calls$Calls,percent = '6.25')
res=WaveletFilter(Calls$Calls,percent = '50')
res=WaveletFilter(Calls$Calls[1:1700],percent = '50')
coeffs=res[[2]]
test=Calls$Calls[1701:1826]
WaveletDecompositionVector <- dwpt(test, 'haar', 1)
timeSeries.basis <- basis(WaveletDecompositionVector, c("w1.0"))
str(coeffs)
for(i in 1:length(coeffs))
WaveletDecompositionVector[[i]] <- timeSeries.basis[i] * coeffs[[i]]
FilteredTS <- idwpt(WaveletDecompositionVector, timeSeries.basis)
points(FilteredTS,col='red')
?`DataIO-package`
?`DatabionicSwarm-package`
projection=Pswarm(FCPS$Hepta$Data,Cls=FCPS$Hepta$Cls,PlotIt=T)
visualization=GeneratePswarmVisualization(Data = FCPS$Hepta$Data,
projection$ProjectedPoints,projection$LC)
Imx = GeneralizedUmatrix::interactiveGeneralizedUmatrixIsland(visualization$Umatrix,
visualization$Bestmatches,Cls)
Imx = GeneralizedUmatrix::interactiveGeneralizedUmatrixIsland(visualization$Umatrix,
visualization$Bestmatch)
Imx = ProjectionBasedClustering::interactiveGeneralizedUmatrixIsland(visualization$Umatrix,
visualization$Bestmatch)
GeneralizedUmatrix::plotTopographicMap(visualization$Umatrix,
visualization$Bestmatches, Cls=Cls,Imx = Imx)
GeneralizedUmatrix::plotTopographicMap(visualization$Umatrix,
visualization$Bestmatches,Imx = Imx)
Cls=DBSclustering(k=7,FCPS$Hepta$Data,
visualization$Bestmatches, visualization$LC,PlotIt=FALSE)
GeneralizedUmatrix::plotTopographicMap(visualization$Umatrix,
visualization$Bestmatches, Cls=Cls,Imx = Imx)
GeneralizedUmatrix::plotTopographicMap(visualization$Umatrix,
visualization$Bestmatches, Cls=Cls,Imx = Imx,BmSize = 2)
library(TimeSeries)
require(prophet)
require(forecast)
#loading data
setwd("D:/Viessmann2018Q2/99RawData/Anrufvolumen")
load(file='CompoundModel.rda') #CompoundModel,TestAndTrain,Verification,Holidays)
##Verification
#prepare data
testandtrainforprophet <- data.frame(ds = as.Date(TestAndTrain$Time),
y = TestAndTrain$Calls)
#build model with settings found in test and train
m <- prophet::prophet(testandtrainforprophet,holidays=Holidays,
seasonality.prior.scale = best_paramsRMSE$seasonality_prior_scale,
changepoint.prior.scale = best_paramsRMSE$changepoint_prior_scale,
holidays.prior.scale = best_paramsRMSE$holidays_prior_scale,
daily.seasonality=best_paramsRMSE$daily_seasonality,yearly.seasonality=best_paramsRMSE$yearly_seasonality)
#forecast for timeframe of verification
future=prophet::make_future_dataframe(m, periods = nrow(Verification), freq = 'day')
forecast <- predict(m, future)
#accuracy
AccuracyVerification=forecast::accuracy(forecast[as.Date(forecast$ds) %in% as.Date(Verification$Time), 'yhat'], Verification$Calls)
AccuracyVerification
#visualized
plot(forecast[as.Date(forecast$ds) %in% as.Date(Verification$Time), 'ds'],forecast[as.Date(forecast$ds) %in% as.Date(Verification$Time), 'yhat'],type='l',
xlab='Time',ylab='Calls',main='Prediction (black), Verification data (red)')
points(Verification$Time,Verification$Calls,col='red')
require(prophet)
require(forecast)
#loading data
setwd("D:/Viessmann2018Q2/99RawData/Anrufvolumen")
load(file='CompoundModel.rda') #CompoundModel,TestAndTrain,Verification,Holidays)
##Verification
#prepare data
testandtrainforprophet <- data.frame(ds = as.Date(TestAndTrain$Time),
y = TestAndTrain$Calls)
## Von Grundprinzip sollte das hier gehen
#prophet::fit.prophet(CompoundModel$Model, data.frame(ds=as.Date(Verification$Time),y=Verification$Calls))
#error: Prophet object can only be fit once. Instantiate a new object.
#Workaround
#build model with settings found in test and train
m <- prophet::prophet(testandtrainforprophet,holidays=Holidays,
seasonality.prior.scale = best_paramsRMSE$seasonality_prior_scale,
changepoint.prior.scale = best_paramsRMSE$changepoint_prior_scale,
holidays.prior.scale = best_paramsRMSE$holidays_prior_scale,
daily.seasonality=best_paramsRMSE$daily_seasonality,yearly.seasonality=best_paramsRMSE$yearly_seasonality)
#forecast for timeframe of verification
future=prophet::make_future_dataframe(m, periods = nrow(Verification), freq = 'day')
forecast <- predict(m, future)
#accuracy
AccuracyVerification=forecast::accuracy(forecast[as.Date(forecast$ds) %in% as.Date(Verification$Time), 'yhat'], Verification$Calls)
AccuracyVerification
#visualized
plot(forecast[as.Date(forecast$ds) %in% as.Date(Verification$Time), 'ds'],forecast[as.Date(forecast$ds) %in% as.Date(Verification$Time), 'yhat'],type='l',
xlab='Time',ylab='Calls',main='Prediction (black), Verification data (red)')
points(Verification$Time,Verification$Calls,col='red')
library(TimeSeries)
library(TimeSeries)
?isoweek
??isoweek
library(TimeSeries)
library(TimeSeries)
library(TimeSeries)
library(TimeSeries)
library(TimeSeries)
library(TimeSeries)
